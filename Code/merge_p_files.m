%%
% Merge all P files in a directory tree which were generated by rolling over due to
% maximum file size setting
%
% Ripped up version from William at Rockland
%
% August-2023, Pat Welch, pat@mousebrains.com

function p_filenames = merge_p_files(p_filenames, merge_dir)
arguments (Input)
    p_filenames table % Output of load_P_file_headers
    merge_dir string {mustBeFolder}
end % arguments Input
arguments (Output)
    p_filenames table % possibly modified version of p_filenames
end % arguments output

tbl = find_files_to_merge(p_filenames);

if isempty(tbl)
    return; % Nothing to be merged
end % if isempty

chains = build_file_lists(tbl); % groups of files to merge
chains.offset = chains.nHeader + chains.nConfig; % Bytes to skip on file
chains.ofn = fullfile(merge_dir, append(chains.nameLHS, ".p"));

ofn = unique(chains.ofn); % Target name
nameLHS = cell(size(ofn));
fnLHS = cell(size(ofn));
dates = cell(size(ofn));

chains = parallel.pool.Constant(chains); % Constant inside of the parfor loop

parfor index = 1:numel(ofn)
    rows = chains.Value(chains.Value.ofn == ofn(index), ...
        ["fnLHS", "dateLHS", "nameLHS", "fileNumber", "fn", "date", "offset"]);
    rows = sortrows(rows, "fileNumber");
    nameLHS{index} = rows.nameLHS(1);
    fnLHS{index} = rows.fnLHS(1);
    dates{index} = merge_files(rows, ofn(index));
end

tbl = table();
tbl.fn = ofn;
tbl.nameLHS = vertcat(nameLHS{:});
tbl.fnLHS = vertcat(fnLHS{:});
tbl.date = vertcat(dates{:});

p_filenames = p_filenames(~ismember(p_filenames.name, chains.Value.name),:); % Drop extra files

% Change fn to point to merged fn
[~, iLHS, iRHS] = innerjoin(p_filenames, tbl, "LeftKeys", "name", "RightKeys", "nameLHS");
p_filenames.fn(iLHS) = tbl.fn(iRHS);
p_filenames.date(iLHS) = tbl.date(iRHS);
end % merge_p_files

function t = merge_files(rows, ofn)
arguments (Input)
    rows table
    ofn string
end % arguments Input
arguments (Output)
    t datetime % file time
end

if isfile(ofn) % ofn already exists, so check if we need to rebuild it
    maxTime = max(max(rows.date), max(rows.dateLHS));
    items = dir(ofn); % Get modification date
    t = datetime(items(1).datenum, "ConvertFrom", "datenum");
    if t > maxTime
        return; % Nothing needs to be done
    end
end

my_mk_directory(ofn, true); % Make sure the directory path exists
tfn = tempname(fileparts(ofn)); % Temporary file to write to in outDir);

ofp = my_open(tfn, "wb"); % Open the tfn file
if ofp == -1
    error("Creating merged p file, %s", ofn);
end % Couldn't open tfn

nBytes = my_copy_file(ofp, rows.fnLHS(1)); % Copy in the first file

for index = 1:size(rows,1)
    nBytes = nBytes + my_copy_file(ofp, rows.fn(index), rows.offset(index));
end

fprintf("Wrote %d MB to %s\n", round(nBytes/1024/1024), ofn)

if ~my_close(ofp, tfn)
    my_delete_file(tfn);
    error("Error closing temporary file, %s, while creating merged p file, %s", tfn, ofn);
end

if ~my_move_file(tfn, ofn) % Failed to move tmpName to ofn
    my_delete_file(tfn);
    error("Error moving %s to %s", tfn, ofn);
end % if ~my_move_file

items = dir(ofn); % Get modification date
t = datetime(items(1).datenum, "ConvertFrom", "datenum");
end % merge_files

function files = build_file_lists(tbl)
arguments (Input)
    tbl table % File pairs to merge, output of find_files_to_merge
end % arguments Input
arguments (Output)
    files table % Cell array of string arrys to merge
end % arguments Output

tbl = sortrows(tbl, "fn"); % Order by right hand fn

for index = 1:size(tbl,1)
    q = tbl.fn(1:end-1) == tbl.fnLHS(2:end);
    if ~any(q)
        break; % Nothing to do
    end % ~any
    indices = find(q);
    tbl.fnLHS(indices+1) = tbl.fnLHS(indices); % Map back to LHS
    tbl.nameLHS(indices+1) = tbl.nameLHS(indices);
    tbl.dateLHS(indices+1) = tbl.dateLHS(indices);
end
files = tbl(:, [ ...
    "fnLHS", "fn", "fileNumber", "date", "bytes", "nHeader", "nConfig", ...
    "name", "nameLHS", "dateLHS"]);
end % build_file_lists

function tbl = find_files_to_merge(p_filenames)
arguments (Input)
    p_filenames table % Output of load_P_file_headers
end % arguments Input
arguments (Output)
    tbl table % Files to merge
end % arguments Output

tbl = p_filenames(p_filenames.version >= 6.1,:); % Only firmware versions >= 6.1 can be merged

tbl.dt = tbl.t1 - tbl.t0; % Time difference between config and first data record

q61 = tbl.version == 6.1;
q62 = tbl.version > 6.1; % Per William
tbl.qMerge = ...
    q61 .* (tbl.dt < seconds(1)) + ...
    q62 .* (tbl.nPrevious ~= 0);

% Backfill nPrevious for firmware version 6.1
q = tbl.qMerge & q61;
tbl.nPrevious(q) = tbl.fileNumber(q) - 1; % Backfill for version 6.1
[tbl.nameLHS, tbl.fnLHS] = mk_LHS_filename(tbl);

% Get name from LHS

[~, iLHS, iRHS] = innerjoin(tbl, tbl, "LeftKeys", "name", "RightKeys", "nameLHS");
tbl.dateLHS = NaT(size(tbl.fnLHS));
tbl.dateLHS(iRHS) = tbl.date(iLHS);

% Check that mergeable files have the same config/operating conditions
[~, iLHS, iRHS] = innerjoin(tbl, tbl, "LeftKeys", "name", "RightKeys", "nameLHS");
q = tbl.configHash(iLHS) == tbl.configHash(iRHS) ...
    & tbl.version(iLHS) == tbl.version(iRHS) ...
    & tbl.fClock(iLHS) == tbl.fClock(iRHS) ...
    & tbl.endian(iLHS) == tbl.endian(iRHS) ...
    & tbl.nData(iLHS) == tbl.nData(iRHS);

tbl = tbl(iRHS(q),:); % Files to be merged
end % find_files_to_merge

function [nameLHS, fnLHS] = mk_LHS_filename(tbl)
arguments (Input)
    tbl table
end % arguments Input
arguments (Output)
    nameLHS (:,1) string
    fnLHS (:,1) string
end % arguments Output

nameLHS = strings(size(tbl.nPrevious));
fnLHS = strings(size(nameLHS));
q = tbl.nPrevious ~= 0;
prevFileNumber = string(num2str(tbl.nPrevious(q), "%04d")); % Previous file's number

[dirname, name, suffix] = fileparts(tbl.fn(q)); % Split up fnRHS
% Join directory, name without last four digits, previous file number, and suffix
nameLHS(q) = append(extractBefore(tbl.name(q), strlength(tbl.name(q)) -3), prevFileNumber);
fnLHS(q) = fullfile(dirname, append(extractBefore(name, strlength(name) - 3), prevFileNumber, suffix));
end % mk_LHS_filename

function qOkay = my_close(fid, fn)
arguments (Input)
    fid double % open file identifier
    fn string % open filename
end % arguments Input

qOkay = fclose(fid) == 0;
if ~qOkay
    fprintf("Error closing %s, %s\n", fn, ferror(fid));
end % if fclose
end % my_close

function fid = my_open(fn, mode)
arguments (Input)
    fn string
    mode string = "rb"
end % arguments (Input)
arguments (Output)
    fid double % File identifier
end % arguments Output

[fid, errmsg] = fopen(fn, mode);

if fid == -1
    fprintf("Error opening %s, %s\n", fn, errmsg);
end % if
end % my_open

function nBytes = my_copy_file(ofp, fn, sPos)
arguments (Input)
    ofp
    fn string {mustBeFile}
    sPos uint32 {mustBeNonnegative} = 0
end

nBytes = 0;

ifp = my_open(fn);
if ifp == -1, return; end 

if sPos > 0 && fseek(ifp, sPos, "bof") ~= 0 % Skip hdr+config if needed
        fprintf("Error seeking to %d in %s, %s\n", sPos, fn, ferror(ifp));
        my_close(ifp, fn);
        return;
end % sPos > 0

nBytes = fwrite(ofp, fread(ifp));
my_close(ifp, fn);
end % my_copy_file

function qOkay = my_delete_file(fn)
arguments (Input)
    fn string {mustBeFile}
end % arguments Input
arguments (Output)
    qOkay logical
end % arguments Output

delete(fn);
fprintf("Deleted %s\n", fn);
qOkay = true;
end

function qOkay = my_move_file(src, dest)
arguments (Input)
    src string {mustBeFile} % source filename
    dest string             % destination filename
end % arguments Input
arguments (Output)
    qOkay logical % Did move succeed?
end % arguments Output

[status, errmsg] = movefile(src, dest);
qOkay = status == 1;
if qOkay
    fprintf("Moved %s to %s\n", src, dest);
else
    fprintf("Error moving %s to %s, %s", src, dest, errmsg);
end % if qOkay
end % my_move_file
