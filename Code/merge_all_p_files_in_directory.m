%%
% Merge all P files in a directory tree which were generated by rolling over due to
% maximum file size setting
%
% Ripped up version from William at Rockland
%
% August-2023, Pat Welch, pat@mousebrains.com

function merge_all_p_files_in_directory(p_file_root, p_file_pattern)
arguments (Input)
    p_file_root string {mustBeFolder} % Root pattern to apply pattern to
    p_file_pattern string="*" % glob pattern to match against, doesn't have .p due to case issues
end % arguments Input

[to_merge, bad_files] = find_p_files_to_merge(p_file_root, p_file_pattern);

move_to_orig(bad_files, true); % Rename bad_files to _original or delete them if _original exists

to_merge = build_file_lists(to_merge); % Build chains of files to merge

for index = 1:numel(to_merge)
    merge_p_files(to_merge{index});
end % for index
end % merge_all_p_files_in_directory

function merge_p_files(filenames)
arguments (Input)
    filenames table % files
end % arguments Input

tmpName = tempname(fileparts(filenames.fn(1))); % Where to write output
ofp = my_open(tmpName, "wb"); % Open the tmpName file
if ofp == -1, return; end % Couldn't open tmpName

for index = 1:size(filenames,1)
    row = filenames(index,:);
    ifp = my_open(row.fn);
    if ifp == -1
        my_close(ofp, tmpName, true); % Close and delete tmpName
        return;
    end

    if row.startPos > 0 % Skip hdr+config if needed
        if fseek(ifp, row.startPos, "bof") ~= 0
            fprintf("Error seeking to %d in %s, %s\n", row.startPos, row.fn, ferror(ifp));
            my_close(ifp, row.fn);
            my_close(ofp, tmpName, true); % Delete after closing
            return;
        end
    end % if row.startPos
    nWrote = fwrite(ofp, fread(ifp));
    my_close(ifp, row.fn);

    if nWrote ~= (row.bytes - double(row.startPos))
        fprintf("Error wrote different amount of bytes, %d instead of %d from %s to %s\n", ...
            nWrote, row.bytes - row.startPos, row.fn, tmpName);
        my_close(ofp, tmpName, true);
        return;
    end
    fprintf("Wrote %d bytes from %s to %s\n", nWrote, row.fn, tmpName);
end

if ~my_close(ofp, tmpName)
    my_delete_file(tmpName);
    return;
end

filenames = move_to_orig(filenames);

if all(filenames.qOkay) % originals have been renamed
    if my_move_file(tmpName, filenames.fn(1)), return; end % Everything worked
end % if qOkay

my_delete_file(tmpName);

move_from_orig(filenames); % Restore files
end % merge_p_files

function [toMerge, toDrop] = find_p_files_to_merge(p_file_root, p_file_pattern)
arguments (Input)
    p_file_root string {mustBeFolder} % Directory to look for pattern files in
    p_file_pattern string="SN*/*" % Glob pattern to append to p_file_root
end % arguments Input
arguments (Output)
    toMerge table % Table of LHS and RHS P files to be merged
    toDrop table % filenames which have problems in the header
end % arguments Output

items = struct2table(dir(fullfile(p_file_root, p_file_pattern))); % find candidate files
items = items(~items.isdir & endsWith(items.name, ".p", "IgnoreCase", true),:); % Not folder and .[Pp]
items = items(~endsWith(items.name, "_original.p", "IgnoreCase", true),:); % Not _original.p
items.fn = string(fullfile(items.folder, items.name));
items = removevars(items, ["name", "folder", "date", "datenum", "isdir"]);

rows = cell(size(items,1),1);

for index = 1:size(items,1)
    [rows{index}, errmsg] = check_p_file(items.fn(index), items.bytes(index));
    if ~ismissing(errmsg)
        fprintf("Error working on %s, %s\n", items.fn(index), errmsg);
    end
end % for index
rows = struct2table(cell2mat(rows));
toDrop = rows(rows.qDrop,:); % List of files which have initial header problems
toMerge = find_files_to_merge(rows); % Table of file pairs to merge
end % find_p_files_to_merge

function files = build_file_lists(tbl)
arguments (Input)
    tbl table % File pairs to merge, output of find_files_to_merge
end % arguments Input
arguments (Output)
    files (:,1) cell % Cell array of string arrys to merge
end % arguments Output

tbl = sortrows(tbl, "t0_LHS"); % Order by start time of LHS file

files = cell(size(tbl,1),1); % More than we need, probably

for index = 1:size(tbl,1)
    row = tbl(index,:);
    if ismissing(row.fnLHS), continue; end % Already handled
    a = cell(size(files,1) + 1,1); % More than we'll need, probably
    startPos = row.nHeader_RHS + row.nConfig_RHS;
    a{end} = struct("fn", row.fnLHS, "bytes", row.bytes_LHS, "startPos", 0, "t0", row.t0_LHS);
    a{index} = struct("fn", row.fnRHS, "bytes", row.bytes_RHS, "startPos", startPos, "t0", row.t0_RHS);
    fnRHS = row.fnRHS;
    for iter = (index + 1):size(tbl,1) % Up to this many additional files
        q = ismember(tbl.fnLHS, fnRHS);
        if ~any(q)
            break;
        end % if ~any
        row0 = tbl(q,:);
        fnRHS = row0.fnRHS;
        tbl.fnLHS(q) = missing;
        a{iter} = struct("fn", fnRHS, "bytes", row0.bytes_RHS, "startPos", startPos, "t0", row0.t0_RHS);
    end % for iter
    a = a(~cellfun(@isempty, a));
    files{index} = sortrows(struct2table(vertcat(a{:})), "t0");
end % for index
files = files(~cellfun(@isempty, files));
end % build_file_lists

function to_merge = find_files_to_merge(rows)
arguments (Input)
    rows table % Output of check_p_file
end % arguments Input
arguments (Output)
    to_merge table % Files to merge
end % arguments Output

q = rows.qMerge;

to_merge = table();
to_merge.fnLHS = mk_LHS_filename(rows.fn(q), rows.fileNumber(q));
to_merge.fnRHS = rows.fn(q);
lhs = innerjoin(to_merge, rows, "LeftKeys", "fnLHS", "RightKeys", "fn");
names = setdiff(lhs.Properties.VariableNames, ["fnLHS", "fnRHS"]);
lhs = renamevars(lhs, names, append(names, "_LHS"));
lhs = innerjoin(lhs, rows, "LeftKeys", "fnRHS", "RightKeys", "fn");
lhs = renamevars(lhs, names, append(names, "_RHS"));
for key = ["configHash", "endian", "version", "nData", "fClock"]
    lhs = lhs(lhs.(append(key, "_LHS")) == lhs.(append(key, "_RHS")), :);
end % if

dt = lhs.t0_RHS - lhs.tEnd_LHS;
to_merge = lhs(dt > seconds(0) & dt < lhs.accuracy_LHS,:);
end % find_files_to_merge

function fnLHS = mk_LHS_filename(fnRHS, fileNumber)
arguments (Input)
    fnRHS (:,1) string
    fileNumber uint16 % 4 digit file number at the end of fnRHS
end % arguments Input
arguments (Output)
    fnLHS (:,1) string
end % arguments Output

prevFileNumber = string(num2str(fileNumber - 1, "%04d")); % Previous file's number

[dirname, name, suffix] = fileparts(fnRHS); % Split up fnRHS
% Join directory, name without last four digits, previous file number, and suffix
fnLHS = fullfile(dirname, append(extractBefore(name, strlength(name) - 3), prevFileNumber, suffix));
end % mk_LHS_filename

function [row, errmsg] = check_p_file(fn, bytes, dtMax)
arguments (Input)
    fn string {mustBeFile} % Filename to check
    bytes uint64 % Size of fn from dir
    dtMax double=0.2; % Maximum difference t1-t0 to be a rollover file
end % arguments Input
arguments (Output)
    row (1,:) struct % Details for this file
    errmsg string % Any error messages for this file
end % arguments Output

row = struct( ...
    "fn", fn, ...
    "bytes", bytes, ...
    "endian", "ieee-be", ... % Try big-endian first
    "qDrop", false, ...
    "qMerge", false, ...
    "fileNumber", nan, ... % Sequence number of the file
    "nHeader", nan, ... % Length in bytes of the header, typically 128
    "nConfig", nan, ... % Length in bytes of configuration payload
    "nData", nan, ...   % Length in bytes of data payload
    "fClock", nan, ...  % Clock frequency
    "version", nan, ... % Firmware version
    "t0", NaT, ... % Time of configuration record
    "t1", NaT, ... % Time of first data record
    "tEnd", NaT, ... % Time of last data record
    "accuracy", seconds(1), ... % Maximum time between successive rollover files
    "configHash", "" ... % Key hash of the config body
    );

[fid, errmsg] = my_open(fn, "rb", row.endian);
if fid == -1, return; end % Failed to open

[hdr, n] = fread(fid, 64, "*uint16"); % Try reading as
if n ~= 64
    my_close(fid, fn);
    errmsg = sprintf("EOF reading header 0, %d != 128 in %s", n, fn);
    row.qDrop = true;
    return;
end % if numel hdr0

if hdr(end) ~= 2 % Not big-endian, so try little endian
    row.endian = "ieee-le"; % Not big-endian, so try little-endian
    my_close(fid, fn);
    fid = my_open(fn, "rb", row.endian); % Reopen with little-endian
    if fid == -1, return; end % Shouldn't happen
    hdr = fread(fid, 64, "*uint16"); % We know there are 64 words
    if hdr(end) ~= 1
        my_close(fid, fn);
        errmsg = sprintf("Unknown endian type, %d, in %s", hdr(end), fn);
        % row.qDrop = true
        return;
    end % hdr
end % if

row.fileNumber = hdr(1); % file number
row.nHeader = hdr(18); % Header size in bytes
row.nConfig = hdr(12); % Configuration body in bytes
row.nData = hdr(19); % Header+data block in bytes
row.fClock = double(hdr(21)) + double(hdr(22)) / 1000;
row.t0 = datetime(hdr(4:9)') + milliseconds(hdr(10));

% MSB has major version, LSB has minor version
row.version = double(bitand(bitshift(hdr(11),-8), 255)) + double(bitand(hdr(11),255)) / 10;
if row.version == 6.1
    row.accuracy = seconds(200); % Maximum gap between successive rollover files
end

[cfg, n] = fread(fid, row.nConfig, "*uint8");
if numel(cfg) ~= row.nConfig
    my_close(fid, fn);
    errmsg = sprintf("Configuration body was not the correct length, %d != %d, in %s", ...
        n, row.nConfig, fn);
    row.qDrop = true;
    return;
end

% Use SHA512 to minimize collison probabilities, for a 20kB ASCII cfg string,
% the collision probability will be <2^(256-16) or ~1 in 10^72
sha512 = java.security.MessageDigest.getInstance("SHA-512");
row.configHash = strjoin(string(dec2hex(typecast(sha512.digest(uint8(cfg)), "uint8"))), "");

[hdr, n] = fread(fid, 64, "*uint16"); % Read the first data header
if n ~= 64
    my_close(fid, fn);
    errmsg = sprintf("EOF reading header 1, %d != 128, in %s", n, fn);
    row.qDrop = true;
    return;
end

row.t1 = datetime(hdr(4:9)') + milliseconds(hdr(10));
dt = seconds(row.t1 - row.t0);
if dt <= 0
    my_close(fid, fn);
    errmsg = sprintf("Invalid times in configuration header, %s, and first data record %s, %s, in %s", ...
        string(row.t0, "yyyy-MM-dd HH:mm:ss.SSS"), ...
        string(row.t1, "yyyy-MM-dd HH:mm:ss.SSS"), ...
        string(dt, "mm:ss.SSS"), ...
        fn);
    return;
end

my_close(fid, fn);

row.qMerge = (row.version) > 6.0 & (dt < dtMax); % Probably a rollover file that can be merged

% Number of data records in the file, should be a whole number
nRecords = double(bytes - uint64(row.nHeader) - uint64(row.nConfig)) / double(row.nData);
% if mod(nRecords, 1) % A fractional part
%     errmsg = sprintf("Fractional records, %f", nRecords);
% end % if
nData = row.nData - row.nHeader; % data words in each data record
% Time of last record
% time of config record + number of records * number of bytes per record over clock frequency
% over 2 bytes per word
row.tEnd = row.t0 + seconds(floor(nRecords) * double(nData) / row.fClock / 2);

errmsg = missing;
end % check_p_file

function filenames = move_to_orig(filenames, qDelete)
arguments (Input)
    filenames table % table with fn column of source filenames
    qDelete logical=false % If orig exists then delete fn
end % arguments Input
arguments (Output)
    filenames table % table with fn column of source filenames
end % arguments Output

filenames.fnOrig = append(filenames.fn, ".orig");
filenames.isfile = isfile(filenames.fnOrig); % Does the original already exist?
filenames.qRenamed = false(size(filenames.fn));
filenames.qDeleted = false(size(filenames.fn));
filenames.qOkay = false(size(filenames.fn));

for index = 1:size(filenames,1)
    row = filenames(index,:);
    fn = row.fn;
    fnOrig = row.fnOrig;
    if ~row.isfile % fnOrig does not exist
        filenames.qRenamed(index) = my_move_file(fn, fnOrig);
        if ~filenames.qRenamed(index), return; end
    elseif qDelete % fnOrig exists, so delete fn
        filenames.qDeleted(index) = my_delete_file(fn);
        if ~filenames.qDeleted(index), return; end
    end % elseif
    filenames.qOkay(index) = true;
end % for index
end % move2orig

function filenames = move_from_orig(filenames)
arguments (Input)
    filenames table % table with fn and fnOrig columns
end % arguments Input

for index = 1:size(filenames,1)
    row = filenames(index,:);
    if row.qRenamed
        filenames.qRenamed(index) = ~my_move_file(row.fnOrig, row.fn);
    elseif row.qDeleted
        filenames.qDeleted(index) = ~my_copy_file(row.fnOrig, row.fn);
    end % if my_move
end % for index
end % move_from_orig

function [qOkay, errmsg] = my_move_file(src, dest)
arguments (Input)
    src string {mustBeFile} % source filename
    dest string             % destination filename
end % arguments Input
arguments (Output)
    qOkay logical % Did move succeed?
    errmsg string % Error message
end % arguments Output

[status, errmsg] = movefile(src, dest);
qOkay = status == 1;
if qOkay
    errmsg = missing;
    fprintf("Moved %s to %s\n", src, dest);
else
    errmsg = sprintf("Error moving %s to %s, %s", src, dest, errmsg);
    fprintf("%s\n", errmsg);
end % if qOkay
end % my_move_file

function [qOkay, errmsg] = my_copy_file(src, dest)
arguments (Input)
    src string {mustBeFile} % source filename
    dest string             % destination filename
end % arguments Input
arguments (Output)
    qOkay logical % Did move succeed?
    errmsg string % Error message
end % arguments Output

[status, errmsg] = copyfile(src, dest);
qOkay = status == 1;
if qOkay
    fprintf("Copied %s to %s\n", src, dest);
else
    errmsg = sprintf("Error copying %s to %s, %s", src, dest, errmsg);
    fprintf("%s\n", errmsg);
end % if qOkay
end % my_copy_file

function [qOkay, errmsg] = my_close(fid, fn, qDelete)
arguments (Input)
    fid double % open file identifier
    fn string % open filename
    qDelete logical = false % Should the file be deleted after closing?
end % arguments Input
arguments (Output)
    qOkay logical % Was the file closed okay
    errmsg string % Error message
end % arguments Output

errmsg = missing;

qOkay = fclose(fid) == 0;
if ~qOkay
    errmsg = sprintf("Error closing %s, %s\n", fn, ferror(fid));
    fprintf("%s\n", errmsg)
end % if qOkay

if qDelete
    my_delete_file(fn);
end % if qDelete
end % my_close

function [fid, errmsg] = my_open(fn, mode, endian)
arguments (Input)
    fn string
    mode string="rb"
    endian string = missing
end % arguments (Input)
arguments (Output)
    fid double % File identifier
    errmsg string % Error message
end % arguments Output

if ismissing(endian)
    [fid, errmsg] = fopen(fn, mode);
else
    [fid, errmsg] = fopen(fn, mode, endian);
end % if ismissing

if fid == -1
    errmsg = sprintf("Error opening %s, %s", fn, errmsg);
    fprintf("%s\n", rrmsg);
end % if
end % my_open

function qOkay = my_delete_file(fn)
arguments (Input)
    fn string {mustBeFile}
end % arguments Input
arguments (Output)
    qOkay logical
end % arguments Output

delete(fn);
fprintf("Deleted %s\n", fn);
qOkay = true;
end
